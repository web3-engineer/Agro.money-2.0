(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["jestMock"] = factory();
	else
		root["jestMock"] = factory();
})(window, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./packages/jest-mock/src/index.ts");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/webpack/buildin/global.js":
/*!***********************************!*\
  !*** (webpack)/buildin/global.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var g; // This works in non-strict mode

g = function () {
  return this;
}();

try {
  // This works if eval is allowed (see CSP)
  g = g || new Function("return this")();
} catch (e) {
  // This works if the window reference is available
  if ((typeof window === "undefined" ? "undefined" : _typeof(window)) === "object") g = window;
} // g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}


module.exports = g;

/***/ }),

/***/ "./packages/jest-mock/src/index.ts":
/*!*****************************************!*\
  !*** ./packages/jest-mock/src/index.ts ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

/**
 * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

/**
 * Possible types of a MockFunctionResult.
 * 'return': The call completed by returning normally.
 * 'throw': The call completed by throwing a value.
 * 'incomplete': The call has not completed yet. This is possible if you read
 *               the  mock function result from within the mock function itself
 *               (or a function called by the mock function).
 */

/**
 * Represents the result of a single call to a mock function.
 */
// see https://github.com/Microsoft/TypeScript/issues/25215
var MOCK_CONSTRUCTOR_NAME = 'mockConstructor';
var FUNCTION_NAME_RESERVED_PATTERN = /[\s!-\/:-@\[-`{-~]/;
var FUNCTION_NAME_RESERVED_REPLACE = new RegExp(FUNCTION_NAME_RESERVED_PATTERN.source, 'g');
var RESERVED_KEYWORDS = new Set(['arguments', 'await', 'break', 'case', 'catch', 'class', 'const', 'continue', 'debugger', 'default', 'delete', 'do', 'else', 'enum', 'eval', 'export', 'extends', 'false', 'finally', 'for', 'function', 'if', 'implements', 'import', 'in', 'instanceof', 'interface', 'let', 'new', 'null', 'package', 'private', 'protected', 'public', 'return', 'static', 'super', 'switch', 'this', 'throw', 'true', 'try', 'typeof', 'var', 'void', 'while', 'with', 'yield']);

function matchArity(fn, length) {
  var mockConstructor;

  switch (length) {
    case 1:
      mockConstructor = function mockConstructor(_a) {
        return fn.apply(this, arguments);
      };

      break;

    case 2:
      mockConstructor = function mockConstructor(_a, _b) {
        return fn.apply(this, arguments);
      };

      break;

    case 3:
      mockConstructor = function mockConstructor(_a, _b, _c) {
        return fn.apply(this, arguments);
      };

      break;

    case 4:
      mockConstructor = function mockConstructor(_a, _b, _c, _d) {
        return fn.apply(this, arguments);
      };

      break;

    case 5:
      mockConstructor = function mockConstructor(_a, _b, _c, _d, _e) {
        return fn.apply(this, arguments);
      };

      break;

    case 6:
      mockConstructor = function mockConstructor(_a, _b, _c, _d, _e, _f) {
        return fn.apply(this, arguments);
      };

      break;

    case 7:
      mockConstructor = function mockConstructor(_a, _b, _c, _d, _e, _f, _g) {
        return fn.apply(this, arguments);
      };

      break;

    case 8:
      mockConstructor = function mockConstructor(_a, _b, _c, _d, _e, _f, _g, _h) {
        return fn.apply(this, arguments);
      };

      break;

    case 9:
      mockConstructor = function mockConstructor(_a, _b, _c, _d, _e, _f, _g, _h, _i) {
        return fn.apply(this, arguments);
      };

      break;

    default:
      mockConstructor = function mockConstructor() {
        return fn.apply(this, arguments);
      };

      break;
  }

  return mockConstructor;
}

function getObjectType(value) {
  return Object.prototype.toString.apply(value).slice(8, -1);
}

function getType(ref) {
  var typeName = getObjectType(ref);

  if (typeName === 'Function' || typeName === 'AsyncFunction' || typeName === 'GeneratorFunction') {
    return 'function';
  } else if (Array.isArray(ref)) {
    return 'array';
  } else if (typeName === 'Object') {
    return 'object';
  } else if (typeName === 'Number' || typeName === 'String' || typeName === 'Boolean' || typeName === 'Symbol') {
    return 'constant';
  } else if (typeName === 'Map' || typeName === 'WeakMap' || typeName === 'Set') {
    return 'collection';
  } else if (typeName === 'RegExp') {
    return 'regexp';
  } else if (ref === undefined) {
    return 'undefined';
  } else if (ref === null) {
    return 'null';
  } else {
    return null;
  }
}

function isReadonlyProp(object, prop) {
  if (prop === 'arguments' || prop === 'caller' || prop === 'callee' || prop === 'name' || prop === 'length') {
    var typeName = getObjectType(object);
    return typeName === 'Function' || typeName === 'AsyncFunction' || typeName === 'GeneratorFunction';
  }

  if (prop === 'source' || prop === 'global' || prop === 'ignoreCase' || prop === 'multiline') {
    return getObjectType(object) === 'RegExp';
  }

  return false;
}

var ModuleMockerClass =
/*#__PURE__*/
function () {
  /**
   * @see README.md
   * @param global Global object of the test environment, used to create
   * mocks
   */
  function ModuleMockerClass(global) {
    _classCallCheck(this, ModuleMockerClass);

    this._environmentGlobal = global;
    this._mockState = new WeakMap();
    this._mockConfigRegistry = new WeakMap();
    this._spyState = new Set();
    this.ModuleMocker = ModuleMockerClass;
    this._invocationCallCounter = 1;
  }

  _createClass(ModuleMockerClass, [{
    key: "_getSlots",
    value: function _getSlots(object) {
      if (!object) {
        return [];
      }

      var slots = new Set();
      var EnvObjectProto = this._environmentGlobal.Object.prototype;
      var EnvFunctionProto = this._environmentGlobal.Function.prototype;
      var EnvRegExpProto = this._environmentGlobal.RegExp.prototype; // Also check the builtins in the current context as they leak through
      // core node modules.

      var ObjectProto = Object.prototype;
      var FunctionProto = Function.prototype;
      var RegExpProto = RegExp.prototype; // Properties of Object.prototype, Function.prototype and RegExp.prototype
      // are never reported as slots

      while (object != null && object !== EnvObjectProto && object !== EnvFunctionProto && object !== EnvRegExpProto && object !== ObjectProto && object !== FunctionProto && object !== RegExpProto) {
        var ownNames = Object.getOwnPropertyNames(object);

        for (var i = 0; i < ownNames.length; i++) {
          var prop = ownNames[i];

          if (!isReadonlyProp(object, prop)) {
            var propDesc = Object.getOwnPropertyDescriptor(object, prop); // @ts-ignore Object.__esModule

            if (propDesc !== undefined && !propDesc.get || object.__esModule) {
              slots.add(prop);
            }
          }
        }

        object = Object.getPrototypeOf(object);
      }

      return Array.from(slots);
    }
  }, {
    key: "_ensureMockConfig",
    value: function _ensureMockConfig(f) {
      var config = this._mockConfigRegistry.get(f);

      if (!config) {
        config = this._defaultMockConfig();

        this._mockConfigRegistry.set(f, config);
      }

      return config;
    }
  }, {
    key: "_ensureMockState",
    value: function _ensureMockState(f) {
      var state = this._mockState.get(f);

      if (!state) {
        state = this._defaultMockState();

        this._mockState.set(f, state);
      }

      return state;
    }
  }, {
    key: "_defaultMockConfig",
    value: function _defaultMockConfig() {
      return {
        defaultReturnValue: undefined,
        isReturnValueLastSet: false,
        mockImpl: undefined,
        mockName: 'jest.fn()',
        specificMockImpls: [],
        specificReturnValues: []
      };
    }
  }, {
    key: "_defaultMockState",
    value: function _defaultMockState() {
      return {
        calls: [],
        instances: [],
        invocationCallOrder: [],
        results: []
      };
    }
  }, {
    key: "_makeComponent",
    value: function _makeComponent(metadata, restore) {
      var _this2 = this;

      if (metadata.type === 'object') {
        return new this._environmentGlobal.Object();
      } else if (metadata.type === 'array') {
        return new this._environmentGlobal.Array();
      } else if (metadata.type === 'regexp') {
        return new this._environmentGlobal.RegExp('');
      } else if (metadata.type === 'constant' || metadata.type === 'collection' || metadata.type === 'null' || metadata.type === 'undefined') {
        return metadata.value;
      } else if (metadata.type === 'function') {
        var prototype = metadata.members && metadata.members.prototype && metadata.members.prototype.members || {};

        var prototypeSlots = this._getSlots(prototype);

        var mocker = this;
        var mockConstructor = matchArity(function () {
          var _this = this,
              _arguments = arguments;

          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }

          var mockState = mocker._ensureMockState(f);

          var mockConfig = mocker._ensureMockConfig(f);

          mockState.instances.push(this);
          mockState.calls.push(args); // Create and record an "incomplete" mock result immediately upon
          // calling rather than waiting for the mock to return. This avoids
          // issues caused by recursion where results can be recorded in the
          // wrong order.

          var mockResult = {
            type: 'incomplete',
            value: undefined
          };
          mockState.results.push(mockResult);
          mockState.invocationCallOrder.push(mocker._invocationCallCounter++); // Will be set to the return value of the mock if an error is not thrown

          var finalReturnValue; // Will be set to the error that is thrown by the mock (if it throws)

          var thrownError; // Will be set to true if the mock throws an error. The presence of a
          // value in `thrownError` is not a 100% reliable indicator because a
          // function could throw a value of undefined.

          var callDidThrowError = false;

          try {
            // The bulk of the implementation is wrapped in an immediately
            // executed arrow function so the return value of the mock function
            // can be easily captured and recorded, despite the many separate
            // return points within the logic.
            finalReturnValue = function () {
              if (_this instanceof f) {
                // This is probably being called as a constructor
                prototypeSlots.forEach(function (slot) {
                  // Copy prototype methods to the instance to make
                  // it easier to interact with mock instance call and
                  // return values
                  if (prototype[